#!/usr/bin/env python

"""

    Build a majority vote tree

"""

# python libs
import sys, os
import optparse

# rasmus libs
from rasmus import treelib
from rasmus import util
from rasmus import stats
from compbio import fasta, phylo

# spidir libs
import spidir




o = optparse.OptionParser()
o.add_option("-o", "--output", dest="outfile", metavar="OUTPUT_FILE",
             help="if specified, write output to file")
o.add_option("-r", "--rooted", dest="rooted",
             action="store_true",
             help="treat trees as rooted")
o.add_option("-a", "--align", dest="align", metavar="FASTA_ALIGNMENT")
o.add_option("-n", "--numtrees", dest="numtrees", metavar="NUMBER",
             type="int",
             help="if given, require a certain number of trees to be present")
o.add_option("-k", "--kappa", dest="kappa", metavar="RATIO",
             type="float",
             default=1.0,
             help="transitition/transversion")
o.add_option("-i", "--maxiter", dest="maxiter", metavar="NUMBER",
             type="int",
             default=20, help="max iterations for ML")

conf, files = o.parse_args()

                
            
def est_bgfreq(aln):
    hist = {"A": 1, "C": 1, "G": 1, "T": 1}
    for seq in aln:
        for c in seq.upper():
            hist[c] = hist.get(c, 0) + 1

    bgfreq = [hist[i] for i in "ACGT"]
    tot = float(sum(bgfreq))
    bgfreq = [i/tot for i in bgfreq]
    return bgfreq


for filename in files:

    # read trees
    trees = treelib.read_trees(filename)
    ntrees = len(trees)

    if conf.numtrees:
        if ntrees < conf.numtrees:
            print "SKIP: %d < %d trees" % (ntrees, conf.numtrees)
            continue
    
    tree = phylo.consensus_majority_vote(trees, rooted=conf.rooted)

   
    if conf.align:
        aln = fasta.read_fasta(conf.align)
        bgfreq = est_bgfreq(aln)
        
        # find actual branch lengths
        spidir.find_ml_branch_lengths_hky(tree, aln, bgfreq, conf.kappa,
                                          maxiter=conf.maxiter, parsinit=True)
    
    if conf.rooted:
        if tree.root.children[0].is_leaf() or \
           tree.root.children[1].is_leaf():
            tree.root.children[0].data["boot"] =  0
            tree.root.children[1].data["boot"] =  0
        else:
            b = (tree.root.children[0].data["boot"] + \
                 tree.root.children[1].data["boot"]) / 2.0
            tree.root.children[0].data["boot"] =  b
            tree.root.children[1].data["boot"] =  b
    
    if conf.outfile:
        tree.write(conf.outfile)
    else:
        tree.write()


