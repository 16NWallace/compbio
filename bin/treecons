#!/usr/bin/env python

"""

    Build a consensus tree

"""

# python libs
import sys, os

# rasmus libs
from rasmus import treelib
from rasmus import util
from rasmus import stats
import optparse

import spidir
from compbio import phylip, fasta, phylo



o = optparse.OptionParser()
o.add_option("-o", "--output", dest="outfile", metavar="OUTPUT_FILE",
             help="if specified, write output to file")
o.add_option("-r", "--rooted", dest="rooted",
             action="store_true",
             help="treat trees as rooted")
o.add_option("-a", "--align", dest="align", metavar="FASTA_ALIGNMENT")
o.add_option("-n", "--numtrees", dest="numtrees", metavar="NUMBER",
             type="int",
             help="if given, require a certain number of trees to be present")
o.add_option("-k", "--kappa", dest="kappa", metavar="RATIO",
             type="float",
             default=1.0,
             help="transitition/transversion")
o.add_option("-i", "--maxiter", dest="maxiter", metavar="NUMBER",
             type="int",
             default=20, help="max iterations for ML")
o.add_option("--binary", dest="binary",
             action="store_true",
             help="ensure consensus tree is binary")

conf, files = o.parse_args()



def ensure_binary(tree):
    
    multibranches = [node for node in tree
                     if len(node.children) > 2]

    for node in multibranches:
        children = list(node.children)
        
        # remove children
        for child in children:
            tree.remove(child)
        
        # add back in binary
        while len(children) > 2:
            left = children.pop()
            right = children.pop()
            newnode = treelib.TreeNode(tree.new_name())
            newnode.data['boot'] = 0
            tree.add_child(newnode, left)
            tree.add_child(newnode, right)
            children.append(newnode)
        
        # add last two to original node
        tree.add_child(node, children.pop())
        tree.add_child(node, children.pop())
            
                
            
def est_bgfreq(aln):
    hist = {"A": 1, "C": 1, "G": 1, "T": 1}
    for seq in aln:
        for c in seq.upper():
            hist[c] = hist.get(c, 0) + 1

    bgfreq = [hist[i] for i in "ACGT"]
    tot = float(sum(bgfreq))
    bgfreq = [i/tot for i in bgfreq]
    return bgfreq


def read_trees(filename):
    infile = open(filename)
    trees = []
    try:
        while 1:
            trees.append(treelib.read_tree(infile))
    except:
        pass
    infile.close()

    return trees


def rename_trees_with_ids(trees):

    names = trees[0].leaf_names()
    for tree in trees:
        phylip.rename_tree_with_ids(tree, names)
    return names



for filename in files:
    args = "y"

    if conf.rooted:
        args = "r\n" + args

    # use id numbers, because phylip crashes on long gene names
    trees = read_trees(filename)
    names = rename_trees_with_ids(trees)
    ntrees = len(trees)

    if conf.numtrees:
        if ntrees < conf.numtrees:
            print "SKIP: %d < %d trees" % (ntrees, conf.numtrees)
            continue

    # run phylip
    tree = phylip.consense(trees, verbose=False, args=args)
    phylip.rename_tree_with_names(tree, names)
    
    
    if conf.align:
        aln = fasta.read_fasta(conf.align)
        bgfreq = est_bgfreq(aln)

        ensure_binary(tree)
        
        # copy bootstrap from dist field
        for node in tree:
            node.data["boot"] = node.dist / ntrees
        
        # find actual branch lengths
        spidir.find_ml_branch_lengths_hky(tree,
                                          util.mget(aln, tree.leaf_names()),
                                          bgfreq,
                                          conf.kappa,
                                          maxiter=conf.maxiter,
                                          parsinit=True)

    else:
        if conf.binary:
            ensure_binary(tree)
    
        for node in tree:
            node.data["boot"] = node.dist / ntrees
            node.dist = 0
    
    if conf.rooted:
        if tree.root.children[0].is_leaf() or \
           tree.root.children[1].is_leaf():
            tree.root.children[0].data["boot"] =  0
            tree.root.children[1].data["boot"] =  0
        else:
            b = (tree.root.children[0].data["boot"] + \
                 tree.root.children[1].data["boot"]) / 2.0
            tree.root.children[0].data["boot"] =  b
            tree.root.children[1].data["boot"] =  b
    
    if conf.outfile:
        tree.write(conf.outfile)
    else:
        tree.write()


