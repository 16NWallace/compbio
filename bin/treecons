#!/usr/bin/env python

"""

    Build a consensus tree

"""

# python libs
import sys, os

# rasmus libs
from rasmus import env, treelib
from rasmus import util
from rasmus import stats

import pyspidir
from rasmus.bio import phylip, phyml, fasta, phylo

def parseBgFreq(txt):
    return map(float, txt.split(","))

options = [
    ["r", "rooted", "rooted", "",
     {"single": True,
      "help": "treat trees as rooted"}],
    ["a:", "align=", "align", "<fasta alignment>",
     {"single": True}],
    ["b:", "bgfreq=", "bgfreq", "<A>,<C>,<G>,<T>",
     {"single": True,
      "parser": parseBgFreq,
      "default": [.25,.25,.25,.25]}],
    ["t:", "tsvratio=", "tsvratio", "<transition/transversion ratio>",
     {"single": True,
      "parser": float,
      "default": 1.0}],
    ["i:", "maxiter=", "maxiter", "<max iterations for ML>",
     {"single": True,
      "parser": int,
      "default": 20}],
    ["", "binary", "binary", "",
     {"single": True,
      "help": "ensure consensus tree is binary"}],
    ["v", "verbose", "verbose", "",
     {"help": "verbose output"}]
]

conf = util.parseOptions(sys.argv, options)



def mlhkydist(aln, tree, bgfreq, ratio, maxiter):
    ptree, nodes, nodelookup = treelib.makePtree(tree)
    leaves = [x.name for x in nodes if isinstance(x.name, str)]
    seqs = util.mget(aln, leaves)
    
    dists, logl = pyspidir.mlhkydist(ptree, seqs, bgfreq, ratio, maxiter)
    
    for i in xrange(len(dists)):
        nodes[i].dist = dists[i]
    
    return logl


def ensure_binary(tree):
    
    multibranches = [node for node in tree
                     if len(node.children) > 2]

    for node in multibranches:
        children = list(node.children)
        
        # remove children
        for child in children:
            tree.remove(child)
        
        # add back in binary
        while len(children) > 2:
            left = children.pop()
            right = children.pop()
            newnode = treelib.TreeNode(tree.newName())
            newnode.data['boot'] = 0
            tree.addChild(newnode, left)
            tree.addChild(newnode, right)
            children.append(newnode)
        
        # add last two to original node
        tree.addChild(node, children.pop())
        tree.addChild(node, children.pop())
            
                
            
            


for filename in conf["REST"]:
    args = "y"

    if conf["rooted"]:
        args = "r\n" + args
    
    tree = phylip.consenseFromFile(filename, False, args)
    ntrees = len(open(filename).readlines())
    
    if "align" in conf:
        aln = fasta.readFasta(conf["align"])

        ensure_binary(tree)
        
        # copy bootstrap from dist field
        for node in tree:
            node.data["boot"] = node.dist / ntrees
        
        # find actual branch lengths
        mlhkydist(aln, tree, conf["bgfreq"], conf["tsvratio"], conf["maxiter"])

    else:
        if conf["binary"]:
            ensure_binary(tree)
    
        for node in tree:
            node.data["boot"] = node.dist / ntrees
            node.dist = 0
    
    if conf["rooted"]:
        if tree.root.children[0].isLeaf() or \
           tree.root.children[1].isLeaf():
            tree.root.children[0].data["boot"] =  0
            tree.root.children[1].data["boot"] =  0
        else:
            b = (tree.root.children[0].data["boot"] + \
                 tree.root.children[1].data["boot"]) / 2.0
            tree.root.children[0].data["boot"] =  b
            tree.root.children[1].data["boot"] =  b
    
    tree.write()






"""
# PHYML
        #tree2 = phyml.phyml(aln, seqtype="dna", usertree=tree, 
        #                    verbose=conf["verbose"],
        #                    opttree=False, optbranches=True)
        #
        #phylo.reconRoot(tree2, tree, lambda x:x, newCopy=False)
        #recon = phylo.reconcile(tree2, tree, lambda x:x)
        #
        #for node2, node in recon.iteritems():
        #    node.data["boot"] = node.dist / 100.0        
        #    node.dist = node2.dist
"""
