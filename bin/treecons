#!/usr/bin/env python

"""

    Build a consensus tree

"""

# python libs
import sys, os

# rasmus libs
from rasmus import treelib
from rasmus import util
from rasmus import stats

import spidir
from compbio import phylip, fasta, phylo

def parseBgFreq(txt):
    return map(float, txt.split(","))

options = [
    ["o:", "outfile=", "outfile", "<output file>",
     {"single": True,
      "help": "if specified, write output to file"}],
    ["r", "rooted", "rooted", "",
     {"single": True,
      "help": "treat trees as rooted"}],
    ["a:", "align=", "align", "<fasta alignment>",
     {"single": True}],
    ["b:", "bgfreq=", "bgfreq", "<A>,<C>,<G>,<T>",
     {"single": True,
      "parser": parseBgFreq}],
    ["n:", "numtrees=", "numtrees", "<expected number of trees>",
        {"single": True,
         "parser": int,
         "help": "if given, require a certain number of trees to be present"}],
    ["k:", "kappa=", "kappa", "<transition/transversion ratio>",
     {"single": True,
      "parser": float,
      "default": 1.0}],
    ["i:", "maxiter=", "maxiter", "<max iterations for ML>",
     {"single": True,
      "parser": int,
      "default": 20}],
    ["", "binary", "binary", "",
     {"single": True,
      "help": "ensure consensus tree is binary"}],
    ["v", "verbose", "verbose", "",
     {"help": "verbose output"}]
]

conf = util.parseOptions(sys.argv, options)



def ensure_binary(tree):
    
    multibranches = [node for node in tree
                     if len(node.children) > 2]

    for node in multibranches:
        children = list(node.children)
        
        # remove children
        for child in children:
            tree.remove(child)
        
        # add back in binary
        while len(children) > 2:
            left = children.pop()
            right = children.pop()
            newnode = treelib.TreeNode(tree.new_name())
            newnode.data['boot'] = 0
            tree.add_child(newnode, left)
            tree.add_child(newnode, right)
            children.append(newnode)
        
        # add last two to original node
        tree.add_child(node, children.pop())
        tree.add_child(node, children.pop())
            
                
            
def est_bgfreq(aln):
    hist = {"A": 1, "C": 1, "G": 1, "T": 1}
    for seq in aln:
        for c in seq.upper():
            hist[c] = hist.get(c, 0) + 1

    bgfreq = [hist[i] for i in "ACGT"]
    tot = float(sum(bgfreq))
    bgfreq = [i/tot for i in bgfreq]
    return bgfreq


for filename in conf["REST"]:
    args = "y"

    if conf["rooted"]:
        args = "r\n" + args

    tree, ntrees = phylip.consense_from_file(filename, False, args)

    if "numtrees" in conf:
        if ntrees < conf["numtrees"]:
            print "SKIP: %d < %d trees" % (ntrees, conf["numtrees"])
            continue
    
    if "align" in conf:
        aln = fasta.read_fasta(conf["align"])

        if "bgfreq" not in conf:
            conf["bgfreq"] = est_bgfreq(aln)

        ensure_binary(tree)
        
        # copy bootstrap from dist field
        for node in tree:
            node.data["boot"] = node.dist / ntrees
        
        # find actual branch lengths
        spidir.find_ml_branch_lengths_hky(tree,
                                          util.mget(aln, tree.leaf_names()),
                                          conf["bgfreq"],
                                          conf["kappa"],
                                          maxiter=conf["maxiter"],
                                          parsinit=True)

    else:
        if conf["binary"]:
            ensure_binary(tree)
    
        for node in tree:
            node.data["boot"] = node.dist / ntrees
            node.dist = 0
    
    if conf["rooted"]:
        if tree.root.children[0].isLeaf() or \
           tree.root.children[1].isLeaf():
            tree.root.children[0].data["boot"] =  0
            tree.root.children[1].data["boot"] =  0
        else:
            b = (tree.root.children[0].data["boot"] + \
                 tree.root.children[1].data["boot"]) / 2.0
            tree.root.children[0].data["boot"] =  b
            tree.root.children[1].data["boot"] =  b
    
    if "outfile" in conf:
        tree.write(conf["outfile"])
    else:
        tree.write()






"""
# PHYML
        #tree2 = phyml.phyml(aln, seqtype="dna", usertree=tree, 
        #                    verbose=conf["verbose"],
        #                    opttree=False, optbranches=True)
        #
        #phylo.reconRoot(tree2, tree, lambda x:x, newCopy=False)
        #recon = phylo.reconcile(tree2, tree, lambda x:x)
        #
        #for node2, node in recon.iteritems():
        #    node.data["boot"] = node.dist / 100.0        
        #    node.dist = node2.dist
"""
