#!/usr/bin/env python
"""

    Simulate a birth death tree on a species tree

"""

# python libs
import sys, time, os, random, math, copy

# rasmus libs
from rasmus import env, treelib
from rasmus import util
from rasmus import stats
import Spidir

from rasmus.bio import alignlib, fasta, phylo, genomeutil, birthdeath

def parseBgFreq(txt):
    return map(float, txt.split(","))


options = [
"""\
    Simulates sequence evolution using SPIDIR's model. 
""",

    ["s:", "stree=", "stree", "<species tree>",
        {"single": True}],
    ["p:", "params=", "params", "<params>",
        {"single": True}],
    ["f:", "famrate=", "famrate", "<family rate>",
        {"single": True,
         "default": None,
         "parser": float}],
    ["l:", "genelen=", "genelen", "<gene length in base pairs>",
        {"single": True,
         "default": 1000,
         "parser": int}],
    ["b:", "bgfreq=", "bgfreq", "<A>,<C>,<G>,<T>",
        {"single": True,
         "default": [.25,.25,.25,.25],
         "parser": parseBgFreq}],
         
    ["D:", "duprate=", "duprate", "<duplication rate>",
        {"single": True,
         "default": 0.0000002,
         "parser": float}],
    ["L:", "lossrate=", "lossrate", "<loss rate>",
        {"single": True,
         "default": 0.0000001,
         "parser": float}],

    ["n:", "ntrees=", "ntrees", "<number of trees to produce>",
        {"single": True,
         "default": 1,
         "parser": int}], 
    ["", "start=", "start", "<starting number>",
        {"single": True,
         "default": 0,
         "parser": int}],
    ["", "nospecrates", "nospecrates", "",
        {"single": True,
         "help": "do not use species rates"}],
            
    "Output extensions",
    ["O:", "outtree=", "outtree", "<output directory>",
        {"single": True,
         "default": "./"}],
    
    ["T:", "outtreeext=", "outtreeext", "<output tree extension>",
        {"single": True,
         "default": ".tree"}],
    ["A:", "outalignext=", "outalignext", "<output align extension>",
        {"single": True,
         "default": ".align"}],


]



conf = util.parseOptions(sys.argv, options, quit=True)



def main(conf):
    # read configuration    
    stree = treelib.readTree(conf["stree"])
    
    if "params" in conf:
        params = Spidir.readParams(conf["params"])
        
        # set species tree lengths
        meanrate = params["baserate"][0] / params["baserate"][1]
        for node in stree:
            node.dist = meanrate * params[node.name][0]
        
    else:
        params = None
        
    if "famrate" in conf:
        generate = conf["famrate"]
    else:
        generate = None
    
    # simulate
    util.tic("simulating %d trees" % conf["ntrees"])
    for i in range(conf["start"], conf["ntrees"]):
        util.log("simulating", i)
        
        # create tree and write it
        pretree, tree = simTree(stree, params, conf["duprate"], conf["lossrate"], 
                       generate, not conf["nospecrates"])
        pretree.write(os.path.join(conf["outtree"], str(i) + ".times" + conf["outtreeext"]))
        tree.write(os.path.join(conf["outtree"], str(i) + conf["outtreeext"]))
        
        outfile = os.path.join(conf["outtree"], str(i))
        simSeq(tree, outfile, seqlen=conf["genelen"], 
               bgfreq=conf["bgfreq"])
        
    util.toc()


def simTree(stree, params, duprate, lossrate, generate, use_spec):
    """simulate one tree"""

    if generate is None:
        # randomly sample gene rate
        generate = random.gammavariate(params["baserate"][0],
                                       1.0 / params["baserate"][1])
    
    tree, recon, events = birthdeath.sample_birth_death_gene_tree(
        stree, duprate, lossrate, removeloss=False)    
    
    pretree = tree.copy()
    prerecon = copy.copy(recon)
    preevents = copy.copy(events)
    removeLosses(pretree, prerecon, preevents)
    meanrate = params["baserate"][0] / params["baserate"][1]
    
    # multiply by generate
    for node in tree:
        if node == tree.root:
            continue
        if use_spec:
            node.dist = simBranchLen(node.dist / meanrate, generate, 
                                     params[recon[node].name][0],
                                     params[recon[node].name][1])
        else:
            node.dist *= generate / meanrate
    
    # trim recon and events structures to only remaining nodes
    doomed = removeLosses(tree, recon, events)
    print "doomed", doomed
    
    return pretree, tree



def simSeq(tree, outfile, seqlen=999, mutaterate=[1.0],
           bgfreq=[.25, .25, .25, .25]):
    print "simulating %s..." % outfile
    
    # remove trailing ';'
    top = tree.getOnelineNewick()[:-1]

    # mutation rates across bases
    mutateratestr = ",".join(map(str, mutaterate))
    mutate = []
    for i in range(0, seqlen, len(mutaterate)):
        mutate.append(mutateratestr)
    mutate = "[" + ",".join(mutate) + "]"

    bgfreqstr = "[" + ",".join(map(str, bgfreq)) + "]"

    rosecmd = """
InputType = 4 // DNA
TheAlphabet = "ACGT"

TheInsertThreshold = 0.05
TheDeleteThreshold = 0.05

TheInsFunc = [.2,.2,.2,.1,.1,.1,.1] // distribution of lengths
TheDelFunc = [.2,.2,.2,.1,.1,.1,.1] // distribution of lengths

MeanSubstitution = 1.0
TTratio = 0.0 // reduces F84 to JC

# output formats
OutputFilebase = "%s"
AlignmentFormat = "FASTA"
SequenceSuffix = ".fasta"
AlignmentSuffix = ".align"
StdOut = False
    
TheFreq = %s
SequenceNum = %d
SequenceLen = %d
TheTree = %s

TheDNAmodel = "HKY"
TransitionBias = 3.18
TheMutationProbability = %s

ChooseFromLeaves = True
TheInsertThreshold = 0.0 // do not model insertions
TheDeleteThreshold = 0.0 // do not model deletions

""" % (outfile, bgfreqstr, len(tree.leaves()), seqlen, top, mutate)

    rose = os.popen("rose -", "w")
    rose.write(rosecmd)
    rose.close()



def removeLosses(tree, recon, events):
    keep = [x for x in tree.leaves() if isinstance(x.name, str)]
    
    nnodes = len(tree.nodes)
    treelib.removeExposedInternalNodes(tree, keep)
    doomed = nnodes - len(tree.nodes)
    
    treelib.removeSingleChildren(tree)
    
    delnodes = set()
    for node in recon:
        if node not in tree.nodes:
            delnodes.add(node)
    for node in delnodes:
        del recon[node]
        del events[node]
    
    return doomed


def simBranchLen(blen, generate, mu, sigma):
    """simulate one branch length"""

    blen2 = 0
    k = blen / mu
    
    while blen2 <= 0:
        blen2 = generate * k * random.normalvariate(mu, sigma)
    
    return blen2


main(conf)
